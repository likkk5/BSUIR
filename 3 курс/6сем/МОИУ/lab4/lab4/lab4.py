import numpy as np

def dual_simplex(c, A, b, B):
    """
    Реализация двойственного симплекс-метода.
    
    Параметры:
    c - коэффициенты целевой функции (вектор)
    A - матрица коэффициентов ограничений (матрица)
    b - вектор правых частей
    B - начальный список базисных индексов (упорядоченный)

    Возвращает:
    Оптимальный вектор x или сообщение о несовместности задачи.
    """

    m, n = A.shape
    B = list(B)  # Копируем начальные базисные индексы
    
    while True:
        # Шаг 1: Формируем базисную матрицу AB и её обратную
        AB = A[:, B]
        AB_inv = np.linalg.inv(AB)

        # Шаг 2: Формируем вектор cB из элементов c с базисными индексами
        cB = c[B]

        # Шаг 3: Вычисляем базисный допустимый план двойственной задачи
        y = cB @ AB_inv

        # Шаг 4: Вычисляем псевдоплан κ
        kappa_B = AB_inv @ b
        kappa = np.zeros(n)
        kappa[B] = kappa_B  # Базисные переменные
        kappa_N = np.zeros(n - m)

        # Шаг 5: Проверяем, является ли κ оптимальным (если все элементы неотрицательны)
        if np.all(kappa >= 0):
            return kappa  # Оптимальный план найден

        # Шаг 6: Находим базисный индекс с отрицательной компонентой псевдоплана
        jk = B[np.argmin(kappa_B)]  # Индекс базисного элемента с мин значением

        # Шаг 7: Вычисляем вектор ∆y (k-я строка матрицы AB_inv)
        delta_y = AB_inv[B.index(jk), :]

        # Шаг 8: Вычисляем µj для всех небазисных переменных
        non_basis = [j for j in range(n) if j not in B]
        mu = {j: delta_y @ A[:, j] for j in non_basis} #Создаем словарь mu с ключом j, для каждого такого j считается mu

        # Если все µj >= 0, задача несовместна
        if all(mu[j] >= 0 for j in non_basis):
            return "Прямая задача несовместна"

        # Шаг 9: Вычисляем σj для всех j, где µj < 0
        sigma = {j: (c[j] - A[:, j] @ y) / mu[j] for j in non_basis if mu[j] < 0}

        # Шаг 10: Находим индекс j0, соответствующий минимальному σ
        j0 = min(sigma, key=sigma.get)

        # Шаг 11: Обновляем базис — заменяем jk на j0
        B[B.index(jk)] = j0

        # Повторяем процесс заново (возвращаемся к шагу 1)


# Пример 1 (обычный случай)
c1 = np.array([-4, -3, -7, 0, 0])
A1 = np.array([
    [-2, -1, -4,  1,  0],
    [-2, -2, -2,  0,  1]
])
b1 = np.array([-1, -1.5])
B1 = [3, 4]  # Начальный базис (нумерация с 0)

solution1 = dual_simplex(c1, A1, b1, B1)
print("Пример 1. Оптимальный план:", solution1)


# Пример 2 (несовместная задача)
c2 = np.array([-1, -1, 0, 0])
A2 = np.array([
    [1, 1, 1, 0],
    [-1, -1, 0, 1]
])
b2 = np.array([-1, -2])
B2 = [2, 3]

solution2 = dual_simplex(c2, A2, b2, B2)
print("Пример 2:", solution2)

