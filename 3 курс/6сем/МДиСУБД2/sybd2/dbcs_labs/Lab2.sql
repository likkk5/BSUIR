-- 1)
-- Создание таблицы GROUPS
CREATE TABLE GROUPS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    C_VAL NUMBER DEFAULT 0
);

-- Создание таблицы STUDENTS
CREATE TABLE STUDENTS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    GROUP_ID NUMBER,
    CONSTRAINT FK_GROUP FOREIGN KEY (GROUP_ID) REFERENCES GROUPS(ID)
);

SHOW USER;

SELECT SYS_CONTEXT('USERENV', 'CON_NAME') FROM DUAL;

SHOW PDBS;

ALTER PLUGGABLE DATABASE ORCLPDB OPEN;

ALTER SESSION SET CONTAINER = ORCLPDB;

CREATE USER user_ksusha2 IDENTIFIED BY "K2510k2510";

GRANT CONNECT, RESOURCE, DBA TO user_ksusha2;
ALTER USER user_ksusha2 QUOTA UNLIMITED ON USERS;

CONNECT user_ksusha/1111@ORCLPDB;
SET SERVEROUTPUT ON;

CONNECT user_ksusha2/K2510k2510@172.17.105.65:1521/ORCLPDB;

-- 2)
-- Триггер для проверки уникальности ID в GROUPS
CREATE OR REPLACE TRIGGER TRG_GROUPS_UNIQUE_ID
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM GROUPS WHERE ID = :NEW.ID;
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ошибка: ID группы должен быть уникальным');
    END IF;
END;

INSERT INTO GROUPS (ID, NAME) VALUES (1, 'Группа A'); -- ОК
INSERT INTO GROUPS (ID, NAME) VALUES (1, 'Группа B'); -- ОШИБКА!

-- Триггер для проверки уникальности ID в STUDENTS
CREATE OR REPLACE TRIGGER TRG_STUDENTS_UNIQUE_ID
BEFORE INSERT OR UPDATE ON STUDENTS
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM STUDENTS WHERE ID = :NEW.ID;
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Ошибка: ID студента должен быть уникальным');
    END IF;
END;

-- Создание последовательностей для автоинкремента
CREATE SEQUENCE SEQ_GROUPS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_STUDENTS START WITH 1 INCREMENT BY 1;

-- Триггер для автоинкремента ID в GROUPS
CREATE OR REPLACE TRIGGER TRG_GROUPS_AI
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    :NEW.ID := COALESCE(:NEW.ID, SEQ_GROUPS.NEXTVAL);
END;

-- Триггер для автоинкремента ID в STUDENTS
CREATE OR REPLACE TRIGGER TRG_STUDENTS_AI
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    :NEW.ID := COALESCE(:NEW.ID, SEQ_STUDENTS.NEXTVAL);
END;

-- Триггер для проверки уникальности NAME в GROUPS
CREATE OR REPLACE TRIGGER TRG_GROUPS_UNIQUE_NAME
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM GROUPS WHERE NAME = :NEW.NAME;
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ошибка: Название группы должно быть уникальным');
    END IF;
END;

-- 3)
CREATE OR REPLACE TRIGGER TRG_CASCADE_DELETE_STUDENTS
AFTER DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;

-- 4)
-- Журналирование изменений STUDENTS
-- Таблица логов с полным сохранением данных
CREATE TABLE STUDENTS_LOG (
    ID NUMBER PRIMARY KEY,
    STUDENT_ID NUMBER,
    NAME VARCHAR2(100),
    GROUP_ID NUMBER,
    ACTION_TYPE VARCHAR2(20),
    ACTION_DATE TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Последовательность для логов
CREATE SEQUENCE SEQ_STUDENTS_LOG START WITH 1 INCREMENT BY 1;

-- Триггер для журналирования изменений
CREATE OR REPLACE TRIGGER TRG_STUDENTS_LOG
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    INSERT INTO STUDENTS_LOG (ID, STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, ACTION_DATE)
    VALUES (
        SEQ_STUDENTS_LOG.NEXTVAL, 
        NVL(:OLD.ID, :NEW.ID), 
        NVL(:OLD.NAME, :NEW.NAME), 
        NVL(:OLD.GROUP_ID, :NEW.GROUP_ID), 
        CASE 
            WHEN INSERTING THEN 'INSERT' 
            WHEN UPDATING THEN 'UPDATE' 
            WHEN DELETING THEN 'DELETE' 
        END, 
        SYSTIMESTAMP
    );
END;

-- 5)
-- Процедура восстановления данных
CREATE OR REPLACE PROCEDURE RESTORE_STUDENTS(p_time TIMESTAMP) AS
BEGIN
    -- Удаляем студентов, чьи изменения были позже p_time
    DELETE FROM STUDENTS WHERE ID IN (
        SELECT STUDENT_ID FROM STUDENTS_LOG WHERE ACTION_DATE > p_time
    );

    -- Вставляем последнюю версию каждого студента до p_time
    INSERT INTO STUDENTS (ID, NAME, GROUP_ID)
    SELECT STUDENT_ID, NAME, GROUP_ID
    FROM STUDENTS_LOG
    WHERE (STUDENT_ID, ACTION_DATE) IN (
        SELECT STUDENT_ID, MAX(ACTION_DATE)
        FROM STUDENTS_LOG
        WHERE ACTION_DATE <= p_time
        GROUP BY STUDENT_ID
    );
END;

-- 6)
-- Триггер обновления C_VAL в GROUPS при изменении STUDENTS
CREATE OR REPLACE TRIGGER TRG_UPDATE_C_VAL
AFTER INSERT OR DELETE OR UPDATE OF GROUP_ID ON STUDENTS
FOR EACH ROW
BEGIN
    -- Обновляем количество студентов в новой группе (если есть)
    IF INSERTING OR (UPDATING AND :NEW.GROUP_ID IS NOT NULL) THEN
        UPDATE GROUPS 
        SET C_VAL = (SELECT COUNT(*) FROM STUDENTS WHERE GROUP_ID = :NEW.GROUP_ID) 
        WHERE ID = :NEW.GROUP_ID;
    END IF;

    -- Обновляем количество студентов в старой группе (если была)
    IF DELETING OR (UPDATING AND :OLD.GROUP_ID IS NOT NULL) THEN
        UPDATE GROUPS 
        SET C_VAL = (SELECT COUNT(*) FROM STUDENTS WHERE GROUP_ID = :OLD.GROUP_ID) 
        WHERE ID = :OLD.GROUP_ID;
    END IF;
END;

