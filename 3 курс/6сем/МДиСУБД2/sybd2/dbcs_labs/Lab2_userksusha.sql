-- Удаление таблиц и последовательностей, если они существуют
DROP TABLE STUDENTS;
DROP TABLE GROUPS;
DROP TABLE STUDENTS_LOG;
DROP SEQUENCE SEQ_GROUPS;
DROP SEQUENCE SEQ_STUDENTS;
DROP SEQUENCE SEQ_STUDENTS_LOG;

-- Создание таблиц
CREATE TABLE GROUPS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    C_VAL NUMBER DEFAULT 0
);

CREATE TABLE STUDENTS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    GROUP_ID NUMBER,
    CONSTRAINT FK_GROUP FOREIGN KEY (GROUP_ID) REFERENCES GROUPS(ID)
);

-- Создание последовательностей для автоинкремента
CREATE SEQUENCE SEQ_GROUPS START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE SEQUENCE SEQ_STUDENTS START WITH 1 INCREMENT BY 1 NOMAXVALUE;

-- Автоинкремент ID для GROUPS
CREATE OR REPLACE TRIGGER AUTO_INCREMENT_GROUPS
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    SELECT SEQ_GROUPS.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
/

-- Автоинкремент ID для STUDENTS
CREATE OR REPLACE TRIGGER AUTO_INCREMENT_STUDENTS
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    SELECT SEQ_STUDENTS.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
/

-- Уникальность ID для GROUPS
CREATE OR REPLACE TRIGGER CHECK_UNIQUE_GROUP_ID
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_ID_GROUP NUMBER;
BEGIN  
    IF :OLD.ID IS NULL OR :OLD.ID != :NEW.ID THEN
        SELECT COUNT(*) INTO COUNT_ID_GROUP FROM GROUPS WHERE ID = :NEW.ID;
        IF COUNT_ID_GROUP != 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY EXISTS!');
        END IF;
    END IF;
END;
/

-- Уникальность ID для STUDENTS
CREATE OR REPLACE TRIGGER CHECK_UNIQUE_STUDENT_ID
BEFORE INSERT OR UPDATE ON STUDENTS
FOR EACH ROW
DECLARE
    COUNT_ID_STUDENT NUMBER;
BEGIN
    IF :OLD.ID IS NULL OR :OLD.ID != :NEW.ID THEN
        SELECT COUNT(*) INTO COUNT_ID_STUDENT FROM STUDENTS WHERE ID = :NEW.ID;
        IF COUNT_ID_STUDENT != 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'ERROR! THIS ID ALREADY EXISTS!');
        END IF;
    END IF;
END;
/

-- Уникальность NAME для GROUPS
CREATE OR REPLACE TRIGGER CHECK_UNIQUE_GROUP_NAME
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    COUNT_NAME_GROUP NUMBER;
BEGIN
    IF :OLD.NAME IS NULL OR :OLD.NAME != :NEW.NAME THEN
        SELECT COUNT(*) INTO COUNT_NAME_GROUP FROM GROUPS WHERE NAME = :NEW.NAME;
        IF COUNT_NAME_GROUP > 0 THEN
            RAISE_APPLICATION_ERROR(-20003, 'ERROR! THIS NAME ALREADY EXISTS!');
        END IF;
    END IF;
END;
/

-- Каскадное удаление студентов при удалении группы
CREATE OR REPLACE TRIGGER CASCADE_DELETE_GROUP 
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;
/

-- Логирование изменений в STUDENTS
CREATE TABLE STUDENTS_LOG (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    STUDENT_ID NUMBER,
    NAME VARCHAR2(100),
    GROUP_ID NUMBER,
    ACTION_TYPE VARCHAR2(20),
    ACTION_DATE TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE SEQUENCE SEQ_STUDENTS_LOG START WITH 1 INCREMENT BY 1 NOMAXVALUE;

CREATE OR REPLACE TRIGGER LOG_STUDENTS_TR
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    CASE
        WHEN INSERTING THEN
            INSERT INTO STUDENTS_LOG (STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, ACTION_DATE)
            VALUES (:NEW.ID, :NEW.NAME, :NEW.GROUP_ID, 'INSERT', SYSTIMESTAMP);
        WHEN UPDATING THEN
            INSERT INTO STUDENTS_LOG (STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, ACTION_DATE)
            VALUES (:OLD.ID, :OLD.NAME, :OLD.GROUP_ID, 'UPDATE', SYSTIMESTAMP);
        WHEN DELETING THEN
            INSERT INTO STUDENTS_LOG (STUDENT_ID, NAME, GROUP_ID, ACTION_TYPE, ACTION_DATE)
            VALUES (:OLD.ID, :OLD.NAME, :OLD.GROUP_ID, 'DELETE', SYSTIMESTAMP);
    END CASE;
END;
/

-- Восстановление данных STUDENTS из логов
CREATE OR REPLACE PROCEDURE RESTORE_STUDENTS(p_time TIMESTAMP) AS
BEGIN
    DELETE FROM STUDENTS WHERE ID IN (
        SELECT STUDENT_ID FROM STUDENTS_LOG WHERE ACTION_DATE > p_time
    );
    INSERT INTO STUDENTS (ID, NAME, GROUP_ID)
    SELECT STUDENT_ID, NAME, GROUP_ID
    FROM STUDENTS_LOG
    WHERE (STUDENT_ID, ACTION_DATE) IN (
        SELECT STUDENT_ID, MAX(ACTION_DATE)
        FROM STUDENTS_LOG
        WHERE ACTION_DATE <= p_time
        GROUP BY STUDENT_ID
    );
END;
/

-- Автообновление C_VAL в GROUPS
CREATE OR REPLACE TRIGGER UPDATE_C_VAL
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
    ELSIF UPDATING THEN
        IF :OLD.GROUP_ID IS NOT NULL THEN
            UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
        END IF;
        IF :NEW.GROUP_ID IS NOT NULL THEN
            UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
        END IF;
    ELSIF DELETING THEN
        UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
    END IF;
END;
/

-- Тестирование триггеров
-- Проверка автоинкремента и уникальности ID
INSERT INTO GROUPS (NAME) VALUES ('Group A');
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Student 1', 1);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Student 2', 1);
-- Попытка вставки студента с существующим ID
INSERT INTO STUDENTS (ID, NAME, GROUP_ID) VALUES (1, 'Duplicate Student', 1); -- Ошибка

-- Проверка логирования
UPDATE STUDENTS SET NAME = 'Updated Student' WHERE ID = 1;
DELETE FROM STUDENTS WHERE ID = 1;
SELECT * FROM STUDENTS_LOG;

-- Проверка каскадного удаления
DELETE FROM GROUPS WHERE ID = 1;
SELECT * FROM STUDENTS; -- Должно быть пусто

-- Проверка уникальности имени группы
INSERT INTO GROUPS (NAME) VALUES ('Group A'); -- Ошибка

-- Проверка автообновления C_VAL
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Student 3', 1);
SELECT * FROM GROUPS; -- C_VAL должно увеличиться

-- Проверка восстановления студентов
CALL RESTORE_STUDENTS(SYSTIMESTAMP - INTERVAL '1' MINUTE);
SELECT * FROM STUDENTS;
