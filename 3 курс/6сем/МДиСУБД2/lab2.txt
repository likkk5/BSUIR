-- 1)
-- Создание таблицы GROUPS
CREATE TABLE GROUPS (
    ID NUMBER, 
    NAME VARCHAR2(100) NOT NULL,
    C_VAL NUMBER DEFAULT 0);
    
-- Создание таблицы STUDENTS    
CREATE TABLE STUDENTS (
    ID NUMBER,
    NAME VARCHAR2(100) NOT NULL, 
    GROUP_ID NUMBER NOT NULL )

SHOW USER;

SELECT SYS_CONTEXT('USERENV', 'CON_NAME') FROM DUAL;

SHOW PDBS;

ALTER PLUGGABLE DATABASE ORCLPDB OPEN;

ALTER SESSION SET CONTAINER = ORCLPDB;

CREATE USER user_ksusha2 IDENTIFIED BY "K2510k2510";

GRANT CONNECT, RESOURCE, DBA TO user_ksusha2;
ALTER USER user_ksusha2 QUOTA UNLIMITED ON USERS;

CONNECT user_ksusha/1111@ORCLPDB;
SET SERVEROUTPUT ON;

CONNECT user_ksusha2/K2510k2510@172.17.105.65:1521/ORCLPDB;    
    
--------------------------------------------------------------------------------
-- 2)
-- Триггер для проверки уникальности NAME в GROUPS
CREATE OR REPLACE TRIGGER TRG_UNIQUE_GROUP_NAME_INSERT
BEFORE INSERT ON GROUPS
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM GROUPS 
    WHERE NAME = :NEW.name AND (id <> :NEW.id OR :NEW.id IS NULL);
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! GROUP WITH THIS NAME ALREADY EXIST!');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_UNIQUE_GROUP_NAME_UPDATE
BEFORE UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM GROUPS 
    WHERE NAME = :NEW.name AND (id <> :NEW.id OR :NEW.id IS NULL);
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! GROUP WITH THIS NAME ALREADY EXIST!');
    END IF;
END;

CREATE OR REPLACE TRIGGER check_if_group_exists_trg
BEFORE INSERT OR UPDATE ON students
FOR EACH ROW
DECLARE 
    t_count NUMBER;
BEGIN
SELECT COUNT(*) INTO t_count FROM groups
    WHERE id = :NEW.group_id;
    
    IF t_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Foreign key for group_id is invalid.');
    END IF;
END;

-- Триггер для проверки уникальности ID в GROUPS
CREATE OR REPLACE TRIGGER TRG_UNIQUE_GROUP_ID
BEFORE INSERT ON GROUPS
FOR EACH ROW
DECLARE
    id_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO id_count FROM GROUPS WHERE ID = :NEW.ID;
    IF id_count != 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;
-- Триггер для проверки уникальности ID в STUDENTS
CREATE OR REPLACE TRIGGER TRG_UNIQUE_STUDENT_ID
BEFORE INSERT ON STUDENTS
FOR EACH ROW
DECLARE
    id_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO id_count FROM STUDENTS WHERE ID = :NEW.ID;
    IF id_count != 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ERROR! THIS ID ALREADY IN TABLE!');
    END IF;
END;


-- Создание последовательностей для автоинкремента
CREATE SEQUENCE SEQ_GROUPS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;
-- Триггер для автоинкремента ID в GROUPS
CREATE OR REPLACE TRIGGER AUTO_INCREMENT_GROUPS
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT SEQ_GROUPS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;



CREATE SEQUENCE SEQ_STUDENTS_ID
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

-- Триггер для автоинкремента ID в STUDENTS
CREATE OR REPLACE TRIGGER AUTO_INCREMENT_STUDENTS
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT SEQ_STUDENTS_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;

--------------------------------------------------------------------------------
-- 3)
CREATE OR REPLACE TRIGGER TR_CASCADE_DELETE_GROUP
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;

--------------------------------------------------------------------------------
-- 4) Журналирование изменений STUDENTS
CREATE TABLE LOG_STUDENTS(
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    USER_NAME VARCHAR2(50),
    DATETIME TIMESTAMP,
    ACTION VARCHAR2(20),
    STUDENT_ID NUMBER,
    STUDENT_NAME VARCHAR2(100),
    GROUP_ID NUMBER);
    
    
CREATE OR REPLACE TRIGGER TR_LOG_STUDENTS
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
CASE
    WHEN INSERTING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'INSERT', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    WHEN UPDATING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'UPDATE', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    WHEN DELETING THEN
        INSERT INTO LOG_STUDENTS (USER_NAME, DATETIME, ACTION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES (USER, SYSTIMESTAMP, 'DELETE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
END CASE;
END;

--------------------------------------------------------------------------------
-- 5)
-- Процедура восстановления данных
CREATE OR REPLACE PROCEDURE RESTORE_STUDENTS (
        p_datetime TIMESTAMP DEFAULT NULL,
        p_offset_minutes NUMBER DEFAULT NULL)
    IS
        v_restore_time TIMESTAMP;
        curr_time TIMESTAMP;
        v_count NUMBER;
BEGIN
    IF p_datetime IS NOT NULL THEN
        v_restore_time := p_datetime;
    ELSIF p_offset_minutes IS NOT NULL THEN
        v_restore_time := SYSTIMESTAMP - INTERVAL '1' MINUTE * p_offset_minutes;
    ELSE 
        RAISE_APPLICATION_ERROR(-20001, 'No recovery option specified');
    END IF;
    
    curr_time := SYSTIMESTAMP;
    
    FOR INFO IN (SELECT ID, STUDENT_ID, STUDENT_NAME, GROUP_ID, ACTION FROM LOG_STUDENTS WHERE DATETIME <= v_restore_time) 
    LOOP
        IF INFO.ACTION = 'INSERT' THEN 
            SELECT COUNT(*) INTO v_count FROM STUDENTS WHERE ID = INFO.STUDENT_ID;
            IF v_count > 0 THEN
                DELETE FROM STUDENTS WHERE ID = INFO.STUDENT_ID;
            END IF;
            INSERT INTO STUDENTS (ID, NAME, GROUP_ID) VALUES (INFO.STUDENT_ID, INFO.STUDENT_NAME, INFO.GROUP_ID);
        ELSIF INFO.ACTION = 'UPDATE' THEN
            UPDATE STUDENTS SET NAME = INFO.STUDENT_NAME, GROUP_ID = INFO.GROUP_ID WHERE ID = INFO.STUDENT_ID;
        ELSIF INFO.ACTION = 'DELETE' THEN
            DELETE FROM STUDENTS WHERE ID = INFO.STUDENT_ID;
        END IF;
    END LOOP;
    
    FOR INFO IN (SELECT STUDENT_ID, STUDENT_NAME, GROUP_ID, ACTION FROM LOG_STUDENTS WHERE (DATETIME > v_restore_time AND DATETIME <= curr_time)) LOOP
        IF INFO.ACTION = 'INSERT' THEN 
            DELETE FROM STUDENTS WHERE ID = INFO.STUDENT_ID;
        END IF;
    END LOOP;

EXCEPTION 
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'ERROR! NO DATA FOUND!');
END;
DROP PROCEDURE RESTORE_STUDENTS;

CREATE TABLE students_snapshots (
            id NUMBER PRIMARY KEY,
            name VARCHAR2(50),
            group_id NUMBER
        );
        
CREATE OR REPLACE PROCEDURE restore_students(
    p_timestamp TIMESTAMP,
    p_offset INTERVAL DAY TO SECOND DEFAULT INTERVAL '0' SECOND
) IS
    v_target_time TIMESTAMP;
BEGIN
    v_target_time := p_timestamp - p_offset;

    DELETE FROM students_snapshots;

    FOR rec IN (
        SELECT student_id, student_name, group_id, ACTION
        FROM LOG_STUDENTS
        WHERE DATETIME <= v_target_time
        ORDER BY DATETIME
    ) LOOP
        IF rec.ACTION = 'INSERT' THEN
            INSERT INTO students_snapshots (id, name, group_id)
            VALUES (rec.student_id, rec.student_name, rec.group_id);
        
        ELSIF rec.ACTION = 'UPDATE' THEN
            UPDATE students_snapshots
            SET name = rec.student_name, group_id = rec.group_id
            WHERE id = rec.student_id;
        
        ELSIF rec.ACTION = 'DELETE' THEN
            DELETE FROM students_snapshots WHERE id = rec.student_id;
        END IF;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Students table is restored for ' || TO_CHAR(v_target_time, 'YYYY-MM-DD HH24:MI:SS'));

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END restore_students;

SET SERVEROUTPUT ON;
BEGIN
    restore_students(TIMESTAMP '2025-02-26 20:15:30');
END;


SELECT * FROM students_snapshots;
--------------------------------------------------------------------------------
-- 6)
-- Триггер обновления C_VAL в GROUPS при изменении STUDENTS
CREATE OR REPLACE TRIGGER TR_UPDATE_C_VAL
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW 
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    IF INSERTING THEN
        UPDATE groups SET c_val = c_val + 1 WHERE id = :NEW.group_id;
    
    ELSIF UPDATING THEN
        IF :OLD.group_id IS NOT NULL THEN
            UPDATE groups SET c_val = c_val - 1 WHERE id = :OLD.group_id;
        END IF;
        IF :NEW.group_id IS NOT NULL THEN
            UPDATE groups SET c_val = c_val + 1 WHERE id = :NEW.group_id;
        END IF;

    ELSIF DELETING THEN
        IF :OLD.group_id IS NOT NULL THEN
            UPDATE groups SET c_val = c_val - 1 WHERE id = :OLD.group_id;
        END IF;
    END IF;
     COMMIT;
END;

--------------------------------------------------------------------------------
SELECT * FROM GROUPS;
SELECT * FROM STUDENTS;
SELECT * FROM LOG_STUDENTS;

TRUNCATE TABLE STUDENTS;
TRUNCATE TABLE LOG_STUDENTS;

INSERT INTO GROUPS (NAME) VALUES ('Group A');
INSERT INTO STUDENTS(NAME, GROUP_ID) VALUES ('Student 2', 1);
INSERT INTO STUDENTS(NAME, GROUP_ID) VALUES ('Student 2', 2);
INSERT INTO STUDENTS(ID, NAME, GROUP_ID) VALUES (1, 'Student 1', 1);

UPDATE STUDENTS SET NAME = 'New name 1' WHERE ID = 1;

DELETE FROM STUDENTS WHERE ID = 3;
DELETE FROM GROUPS WHERE ID = 2;

BEGIN
    RESTORE_STUDENTS(NULL, 10);
END;

BEGIN
    RESTORE_STUDENTS('26-FEB-2025 04:55:50');
END;

--EXECUTE RESTORE_STUDENTS(TO_TIMESTAMP('2025-02-23 02:44:30', 'YYYY-MM-DD HH24:MI:SS'));